Class kutac.monitor.utils.Installer
{

XData Install [ XMLNamespace = INSTALLER ]
{
<Manifest>
<IfNotDef Var="Namespace">
<Var Name="Namespace" Value="SYSMON"/>
<Log Text="Set namespace to ${Namespace}" Level="0"/>
</IfNotDef>


<If Condition='(##class(Config.Namespaces).Exists("${Namespace}")=0)'>
<Log Text="Creating namespace ${Namespace}" Level="0"/>

<Namespace Name="${Namespace}" Create="yes" Code="${Namespace}" Ensemble="" Data="${Namespace}">
<Log Text="Creating database ${Namespace}" Level="0"/>

<Configuration>
<Database Name="${Namespace}" Dir="${MGRDIR}/${Namespace}" Create="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/>
</Configuration>

<Log Text="End creating database ${Namespace}" Level="0"/>
</Namespace>

 <Log Text="End creating namespace ${Namespace}" Level="0"/>
</If>


<If Condition='(##class(Security.Applications).Exists($ZCONVERT("/csp/${Namespace}", "L"))=0)'>
<Namespace Name="${Namespace}" Create="no">
<Log Text="Creating web application /csp/${Namespace}" Level="0"/>

<CSPApplication Url='#{$ZCONVERT("/csp/${Namespace}", "L")}' Directory='#{##class(%DeepSee.Report.UI.reportModelServer).GetCSPDirectory()_$ZCONVERT("${Namespace}", "L")}' AuthenticationMethods="64" IsNamespaceDefault="true" Recurse="true" Grant="%All"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="EnableDeepSee"/>

<Log Text="End creating web application /csp/${Namespace}" Level="0"/>
</Namespace>
</If>


<Namespace Name="${Namespace}" Create="no">
<IfDef Var="SourceDir">
<Log Text="SourceDir defined - offline install from ${SourceDir}" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="OfflineInstall"/>
</IfDef>

<IfNotDef Var="SourceDir">
<Log Text="SourceDir undefined - online install from GitHub" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="DownloadFromGitHub"/>
</IfNotDef>
</Namespace>


<Namespace Name="${Namespace}" Create="no" Code="${Namespace}" Data="${Namespace}" Ensemble="">
<Log Text="Mapping SYS.History package to choosed namespace." Level="0"/>

<Configuration>
<ClassMapping From="CACHESYS" Package="SYS.History"/>
</Configuration>

<Log Text="Mapping SYS.History global to choosed namespace." Level="0"/>

<Configuration>
<GlobalMapping From="CACHESYS" Global="SYS.History"/>
</Configuration>

<Log Text="Mapping MONEXT routine to choosed namespace." Level="0"/>

<Configuration>
<RoutineMapping From="CACHESYS" Routines="MONEXT"/>
</Configuration>
</Namespace>

<If Condition='##class(Config.Namespaces).Exists("MDX2JSON")'>
<Log Text="Setup DSW settings." Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="SetDSWSettings"/>
</If>


<Log Text="Moving to configuring monitor" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="ConfiguringMonitor"/>


<!--<Log Text="Configuring startup namespace" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="ConfiguringClasses"/>

<Log Text="Activating Monitor Classes" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="ActivatingingClasses"/>

<Log Text="Starting Monitor" Level="0"/>
<RunInstall Class="kutac.monitor.utils.Installer" Method="RunningMonitor"/>-->



</Manifest>
}

///  This is a method generator whose code is generated by XGL.
/// Set pVars("Namespace")="SYSMON"
/// Set pVars("SourceDir")="C:\temp\SYSMON\cls\kutac\"
/// do ##class(kutac.monitor.utils.Installer).setup(.pVars)
ClassMethod setup(ByRef pVars, pLogLevel As %Integer = 0, pInstaller As %Installer.Installer) As %Status [ CodeMode = objectgenerator, Internal ]
{
 	Quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Install")
}

ClassMethod EnableDeepSee(pVars, pLogLevel, tInstaller) As %Status
{
	set namespace = tInstaller.Evaluate("${Namespace}")
	do EnableDeepSee^%SYS.cspServer("/csp/"_$ZCONVERT(namespace, "L")_"/")
	quit $$$OK
}

ClassMethod DownloadFromGitHub(pVars, pLogLevel, tInstaller) As %Status
{
    Set Namespace=tInstaller.Evaluate("${Namespace}")
    Do tInstaller.PushNS("%SYS")
    Set tSC = ..Update(Namespace, "intersystems-ru", "deepsee-sysmon-dashboards", "UDL")
    Do tInstaller.PopNS()
    If $$$ISERR(tSC) Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
    quit $$$OK
}

ClassMethod Update(Namespace = {$Namespace}, Owner As %String = "intersystems-ru", Repository As %String = "deepsee-sysmon-dashboards", Branch As %String, Username As %String, Password As %String) As %Status
{
	Set namespace = $Namespace
 	Set SSLConfig = "GitHub"
 	Zn "%SYS"
 	Do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)

 	Set req=##class(%Net.HttpRequest).%New()
 	Set req.Https=1
	Set req.SSLConfiguration=SSLConfig
	Set req.Server="api.github.com"
	Set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/contents" 	// as described in https://developer.github.com/v3/repos/	
	Do:$d(Branch) req.SetParam("ref",Branch) 								// if omitted the repository’s default branch (usually master) would be used
	Do req.SetHeader("Accept","application/vnd.github.v3+json") 			// we want to receive API v3
	
	If ($d(Username) && $d(Password)) {										// supply Username and Passwor, if both are provided. GitHub accept Basic Auth
		Set req.Username = Username											// https://developer.github.com/v3/auth/
	 	Set req.Password = Password
	} 	

 	Set links = ##class(%ListOfDataTypes).%New()
 	Set st = ..ProcessDirectory("",req,.links)
 	Return:$$$ISERR(st) st
 	 	
 	Zn Namespace
	Set st = ..DownloadFiles(links,req,.list)
	Set st2 = $system.OBJ.CompileList(.list,"cuk /checkuptodate=expandedonly")
	Zn namespace
	
 	Return $$$ADDSC(st, st2)
}

ClassMethod ProcessDirectory(Path As %String = "", Request As %Net.HttpRequest, ByRef Links As %ListOfDataTypes) As %Status
{
	Set location = Request.Location
	Set Request.Location = Request.Location _ Path
	
	Set st = Request.Get(,,$$$NO)
	Return:$$$ISERR(st) st
	Return:(Request.HttpResponse.StatusCode = 404) $$$ERROR($$$GeneralError,"Repository doesn't exist OR you don't have access")
	Return:((Request.HttpResponse.StatusCode = 403) && (Request.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) $$$ERROR($$$GeneralError,"API rate limit exceeded. Try logging in.")
 	Return:(Request.HttpResponse.StatusCode '= 200) $$$ERROR($$$GeneralError,"Received " _ Request.HttpResponse.StatusCode _ " status, expected 200")
 	
 	#dim objects As List of %ZEN.proxyObject
 	#dim obj As %ZEN.proxyObject
	Set st = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Request.HttpResponse.Data,,.objects,1)
	Return:$$$ISERR(st) st
	
	For i = 1:1:objects.Count() {		
		Set obj = objects.GetAt(i)
		If (obj.type = "dir") {
			Set st = ..ProcessDirectory("/"_obj.name,Request,.Links)
			Return:$$$ISERR(st) st		
		} ElseIf (obj.type = "file") {
			//Do:..IsCacheFile(obj) Links.Insert(obj."download_url")
			Do Links.Insert($LB(obj."download_url",..IsCacheFile(obj)))
		} Else {
			// obj.type = "symlink" or obj.type = "submodule"
		} 
	}
	Set Request.Location = location // to keep track of where in the repository tree we are
	Return $$$OK
}

ClassMethod IsCacheFile(File As %ZEN.proxyObject) As %Boolean
{
	Set extensions = ",xml,cls,csp,csr,mac,int,bas,inc,gbl,prj,obj,pkg,gof,dfi,pivot,dashboard,html,css,js,ts,scss,"
	Return:($L(File.name,".")=1) 0 //no extension
	Set File.Extension = $P(File.name,".",$L(File.name,"."))
	Return $F(extensions,","_$ZCVT(File.Extension,"l")_",")
}

ClassMethod DownloadFiles(Links As %ListOfDataTypes, Request As %Net.HttpRequest, Output Items) As %Status
{
	Kill Items
	Set Request.Server = "raw.githubusercontent.com"
	Set st = $$$OK
	Try
	{
		For i = 1:1:Links.Count() {
		//Set link = Links.GetAt(i)
		Set link = $ListGet(Links.GetAt(i),1)
		Set bIsCacheFile = $ListGet(Links.GetAt(i),2)
		Set ^gitfiles(i,"link")=link
		Set ^gitfiles(i,"bIsCacheFile")=bIsCacheFile
		
		
		Set streq = Request.Get($e(link,35,*)) // Remove "https://raw.githubusercontent.com/" from URL.	
		//Set:$$$ISERR(streq) st=$$$ADDSC(st, streq)
		
		
		If $$$ISERR(streq)
		{
			Set st=$$$ADDSC(st, streq)
			Set ^gitfiles(i,"streq")=streq
			Continue
		}
		Set ^gitfiles(i,"stream")="starting..."
		
		
		Set binarystream = Request.HttpResponse.Data
		Do binarystream.Rewind() // just in case
		
		Set stream=##class(%GlobalCharacterStream).%New() //translating binary stream into character stream
		Set stTranslate=$$$OK
		Try
		{
			While 'binarystream.AtEnd { 
				//Use eol to prevent breaking lines larger than 32Kb
				Set line=binarystream.ReadLine(, .stTranslate, .eol)
				Quit:$System.Status.IsError(stTranslate)
							
				If eol
				{
					Set stTranslate=characterStream.WriteLine(line)
				}
				Else
				{
					Set stTranslate=characterStream.Write(line)
				}
				Quit:$System.Status.IsError(stTranslate) 
			}
			Quit:$System.Status.IsError(stTranslate)
			
			Do stream.Rewind()
		}
		Catch (oTranslateStreamException)
		{
			Set stTranslate=oTranslateStreamException.AsStatus()
		}
		
		If $System.Status.IsError(stTranslate)
		{
			//Could not convert binary stream to character stream
			//It is probably a binary file anyway
			Set stream=""
			Set st=$$$ADDSC(st, stTranslate)
			Set ^gitfiles(i,"stTranslate")=stTranslate
		}
		Set ^gitfiles(i,"stream")="Done"
		
		Do binarystream.Rewind()
			
		Set stload = $$$OK
			
		set items = ""
		If ('$IsObject(stream)) || (..IsUDLFile(stream)) 
		{
			Set ^gitfiles(i,"IsUDLFile")="1"
			set stload = ..LoadUDLFile(stream, binarystream, link, .items)
		}
		ElseIf ..IsWebFile(stream, link)
		{
			Set stload = ..LoadWebFile(binarystream, link,"csp/")
		}
		ElseIf bIsCacheFile
		{
			Set ^gitfiles(i,"IsUDLFile")="0"
			Set stload = $system.OBJ.LoadStream(characterStream,"",.error,.items,,,,"UTF8")
		}
		
 		Set ^gitfiles(i,"stload")=stload
 		If $$$ISERR(stload)
 		{
	 		Set st=$$$ADDSC(st, stload)
	 		Continue
 		}
 		Merge Items = items  // Does not overwrite existing array keys: Items(itemname)=""
	}
	
	Set Request.Server="api.github.com"
	}
	Catch (oException)
	{
		Set st = oException.AsStatus()
		If $D(i) Set ^gitfiles(i,"st final")=st
	}
	
	Return st
}

ClassMethod IsWebFile(contentStream As %GlobalCharacterStream, url As %String) As %Boolean
{
	set params = $find(url, "?")
 	if params {
 		set url = $extract(url, 1, params - 2)
 	}
	
	Set extensions = "csp,js,html,css"
	If $Find(extensions, $Piece(url, ".", *)) {
		Set st = ##class(%XML.TextReader).ParseStream(contentStream)
		Do contentStream.Rewind()
		If $$$ISERR(st) {
			Return $$$YES
		}
		Else {
			Return $$$NO
		}
	}
	Else {
		Return $$$NO
	}
}

// Класс не универсальный, загрузку web составляющей нужно прописывать самому. Эта информация для тех кто хочет просто скопипастить этот метод.

ClassMethod LoadWebFile(contentStream As %CacheString, url As %String, CSPDirInRepo As %String = "csp/") As %Status
{
	Set st = $$$OK
	
	Set filestream = ##class(%Stream.FileCharacter).%New()
	Do contentStream.Rewind()
	do filestream.Rewind()
	
	set CSPPath = $system.CSP.GetFileName($system.CSP.GetDefaultApp($namespace)_"/")
	set fileDirectory = $Piece(url, CSPDirInRepo, *)
	set dirChain = $p(CSPPath_fileDirectory,$p($translate(CSPPath_fileDirectory,"\","/"),"/",*),1)
	do ##class(%File).CreateDirectoryChain(dirChain)
	set st = filestream.LinkToFile(CSPPath_fileDirectory)
	
	While 'contentStream.AtEnd
	{
		Do filestream.WriteLine(contentStream.ReadLine())
	}
	if $$$ISERR(st) Quit st
	
	set st = filestream.%Save()
	Return st
}

ClassMethod IsUDLFile(stream As %GlobalCharacterStream) As %Boolean
{
	// probably 10 lines is enough
	set counter = 0 
	while 'stream.AtEnd {
		if counter >= 10 {
			quit
		}
		set line = stream.ReadLine()
		if $find(line, "<Export") {
			do stream.Rewind()
			return $$$NO
		}
		set counter = counter + 1
	}
	do stream.Rewind()
	
	return $$$YES
}

ClassMethod LoadUDLFile(contentStream As %GlobalCharacterStream, binaryStream As %Stream.FileCharacterGzip, url As %String, list As %String) As %Status
{
	set st = $$$OK
	
	set ext = ..GetExt(url)
	
	if ext = "cls" {
		set st = ..CreateClass(contentStream, url, .list)
	}
	elseif ext = "dfi" {
		set st = ..CreateDFI(contentStream, url, .list)
	}
	elseif (ext = "inc") || (ext = "mac") {
		set st = ..CreateRoutine(contentStream, url, .list)
	} 
	
	Return st
}

ClassMethod GetExt(url As %String) As %String
{
	//return $zconvert($piece(url, ".", *), "l")
	//AMIR: There are parameters after the extension that are not part of the extension
	return $zconvert($piece($piece(url, ".", *),"?"), "l")
}

ClassMethod CreateClass(contentStream As %CharacterStream, url As %String, ByRef list As %String) As %Status
{
	Set st = ..GetClassName(contentStream, .className)
	Return:$$$ISERR(st) st
	
	set list(className _ ".cls") = ""
	
	Do contentStream.Rewind()
	
	If '..DoesClassExist(className) {
		Set clsDef = ##class(%Dictionary.ClassDefinition).%New()
		Set clsDef.Name = className
		Set st = clsDef.%Save()
		Return:$$$ISERR(st) st
	}

	
	Set namespace = $namespace
	Set st = ##class(%Compiler.UDL.TextServices).SetTextFromStream(namespace, className, contentStream)
	
	if st {
		w !, "Imported " _ className, !
	}
	
	Return st
}

ClassMethod GetClassName(stream As %GlobalCharacterStream, ByRef name As %String) As %Status
{
	while 'stream.AtEnd {
		set line = stream.ReadLine()
		
		if $extract(line, 1, 3) = "///" { // check for inline comments
			continue
		} elseif $zconvert($extract(line, 1, 5), "l") = "class" {
			set line = $extract(line, 6, *)
			set name = ..ReadName(line)
			if name = "" {
				return '$$$OK
			} else {
				return $$$OK
			}
		}
	}
	return '$$$OK
}

ClassMethod DoesClassExist(className As %String) As %Boolean
{
	Set query = "SELECT TOP 1 COUNT(ID) FROM %Dictionary.ClassDefinition WHERE ID = ?"
	Set statement = ##class(%SQL.Statement).%New()
	Set st = statement.%Prepare(query)
	Set rset = statement.%Execute(className)
	If (rset.%Next()) && (rset.%ROWCOUNT > 0) {
		Return $$$YES
	}
	Return $$$NO
}

ClassMethod CreateDFI(contentStream As %CharacterStream, url As %String, ByRef list As %String) As %Status
{
	Set st = $$$OK
    Try {
	    Set st = ..GetDFIName(contentStream, .name)
	    Return:$$$ISERR(st) st
	    
	    set list(name) = ""
	    
        Set tDoc = ##class(%DeepSee.UI.FolderItemDocument).%New(name)
        Set st = tDoc.ImportFromXML(contentStream)
        Return:$$$ISERR(st) st
        
        Set st = tDoc.Save()
        if st {
		w !, "Imported " _ name, !
	}
        Return:$$$ISERR(st) st
    } Catch e {
        Set st = e.AsStatus()
    }
    Return st
}

ClassMethod GetDFIName(stream As %GlobalCharacterStream, ByRef name As %String) As %Status
{
	#dim textreader As %XML.TextReader
	set dfiContent = ""
	
	// I don't know why but if i just parse stream it doesn't work
	while 'stream.AtEnd {
		set dfiContent = dfiContent _ stream.Read()
	}
	
	set st = ##class(%XML.TextReader).ParseString(dfiContent, .textreader)
	return:$$$ISERR(st) st
	
	while textreader.Read() {
		set node = textreader.Name
		if (node = "pivot") || (node = "dashboard") {
			do textreader.MoveToAttributeName("folderName")
			set dfiFolderName = $translate(textreader.Value, " ", "-")
			
			do textreader.MoveToAttributeName("name")
			set dfiName = $translate(textreader.Value, " ", "-")
			
			set name = dfiFolderName _ "-" _ dfiName _ "." _ node _ ".dfi"
			return $$$OK
		}
	}
	return '$$$OK
}

ClassMethod CreateRoutine(contentStream As %GlobalCharacterStream, url As %String, ByRef list As %String) As %Status
{
	Set st = ..GetRoutineName(contentStream, .name, .type)
	do contentStream.Rewind()
	
	return:$$$ISERR(st) st
	
	if type = 1 {
		set name = name _ ".mac"
	} 
	elseif type = 2 {
		set name = name _ ".inc"
	}
	elseif type = 3 {
		set name = name _ ".int"
	}
	
	set list(name) = ""
		
	Set rtn = ##class(%Routine).%New(name)
	While 'contentStream.AtEnd {
		Set line = contentStream.ReadLine()
		If $Find(line, "ROUTINE") {
			Continue
		}
		Do rtn.WriteLine(line)
	}
	
	Set st = rtn.Save()
 	Return:$$$ISERR(st) st
 	
 	if st {
		w !, "Imported " _ name, !
	}
 	Return st
}

ClassMethod GetRoutineName(stream As %GlobalCharacterStream, ByRef name As %String, ByRef type As %Integer) As %Status
{
	while 'stream.AtEnd {
		set line = stream.ReadLine()
		set index = $find(line, "ROUTINE")
		// TODO - check whether the name on the next line 
		// or something is between ROUTINE and name
		if index {
			if $find(line, "[Type=INC]") {
				set type = 2
			}
			elseif $find(line, "[Type=INT,Generated]") {
				set type = 3
			}
			else {
				set type = 1
			}
			set line = $extract(line, index, *)
			set name = ..ReadName(line)
			if name = "" {
				return '$$$OK
			} else {
				return $$$OK
			}
		}
	}
	return '$$$OK
}

ClassMethod ReadName(line As %String) As %String
{
	set trimmed = $zstrip(line, "<>W")
	return $piece(trimmed, " ")
}

ClassMethod ConfiguringMonitor(pVars, pLogLevel, tInstaller) As %Status
{
	Set Namespace=tInstaller.Evaluate("${Namespace}")
	Do tInstaller.PushNS("%SYS")
	write !, "Activating Monitor Classes"
	set st2 = ..ActivatingClasses()
	write !, "Starting Monitor", !
	set st3 = ..RunningMonitor()
	Do tInstaller.PopNS()
	Do tInstaller.PushNS(Namespace)
	&sql(select Name from %SYS.Task where Name = 'Rebuild SYSMON Cubes')
	if +SQLCODE 
	{
		write "Creating Task",!
		Do ##class(kutac.monitor.task.Builder).Setup()
	}
	Do tInstaller.PopNS()
	set st = $$$ADDSC(st2, st3)
	if $$$ISERR(st) Throw ##class(%Installer.Exception).CreateFromStatus(st)
    quit $$$OK
}

ClassMethod ActivatingClasses() As %Status
{
	set act = $LISTBUILD("%Monitor.System.HistoryPerf","%Monitor.System.Diskspace","%Monitor.System.License","%Monitor.System.Processes","%Monitor.System.HistorySys","%Monitor.System.Freespace","%Monitor.System.LockTable","%Monitor.System.Routines")
	set str = $LISTTOSTRING(act)
	for i = 1:1:$LISTLENGTH(act)
	{
		set cls = $PIECE(str, ",", i)
		set id = ""
		do ##class(%Monitor.ItemGroup).MetricsClassItemGroup(cls,.id)
 		s class = ##class(%Monitor.ItemGroup).%OpenId(id)
 		if '$IsObject(class)
 		{ 
 			write !,"ERROR: Class '"_cls_"' does not exist",!
 		}
 		else
 		{
	 		set class.Activated = 1
	 		set status = class.%Save()
	 		if ('status) 
	 		{
		 		w $System.Status.GetErrorText(st)
	 		}
 		}
	}
	return $$$OK
}

ClassMethod RunningMonitor() As %Status
{
	s sc = ##class(%SYS.Monitor).Stop()
	s sc1 = ##class(%SYS.Monitor).Start()
	w "System Monitor has been restarted!", !
	return sc1
}

ClassMethod OfflineInstall(ByRef pVars, pLogLevel As %Integer = 0, tInstaller As %Installer.Installer) As %Status
{
	set ns = $Namespace
	set namespace = tInstaller.Evaluate("${Namespace}")
	
	zn namespace
	do $system.OBJ.ImportDir(tInstaller.Evaluate("${SourceDir}"),"*.xml","ck",.st,1)
	
	zn ns
	quit $$$OK
}

ClassMethod SetDSWSettings(pVars, pLogLevel, tInstaller) As %Status
{
	set id = $classname()_"||DSWSettings"
	quit:(##class(%Dictionary.CompiledXData).%ExistsId(id) = 0) $$$ERROR($$$GeneralError,"You don't export DSW settings")	
	set xdata = ##class(%Dictionary.CompiledXData).%OpenId(id)
	
	set settings = xdata.Data.Read()
	if (##class(%Dictionary.CompiledMethod).%ExistsId("MDX2JSON.Users||SetConfig"))
	{
		do ##class(MDX2JSON.Users).SetConfig(tInstaller.Evaluate("${Namespace}"),settings,"DeepSeeWeb")
	}
	else{w "Please, update MDX2JSON."}
	quit $$$OK
}

XData DSWSettings [ MimeType = text/plain ]
{
{"Default":{"addons":"","app":{"language":"en","hideFolders":false,"showImages":true,"isMetro":false},"namespaces":{"widgets":{"mobile/Current Performance Indicators.dashboard":{"ObjPerf":{"sizeY":7,"sizeX":3,"col":6},"GlobPerf":{"col":4,"sizeY":5,"sizeX":2}},"mobile/GloPerf.dashboard":{"w2":{"sizeY":5,"sizeX":10}},"dash/actions/State Info.dashboard":{"Widget1":{"col":0}},"mobile/ObjPerf.dashboard":{"_filters":[{"targetProperty":"[Measurement Date].[H1].[Month]","value":"&[NOW]"},{"targetProperty":"[Measurement Date].[H1].[Day]","value":"&[13]"}]},"mobile/DBSizes.dashboard":{"w2":{"series":{}}}},"tiles":{"mobile/":{"":{"row":0,"col":0,"sizeX":1,"sizeY":1,"color":2,"fontColor":0,"icon":27,"title":""},"CPU Utilization":{"row":0,"col":1,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"CPU Utilization"},"Current Performance Indicators":{"row":3,"col":2,"sizeX":2,"sizeY":2,"color":1,"fontColor":0,"icon":0,"hideTitle":true,"widget":0,"title":"Current Performance Indicators"},"Current Performance Objects":{"row":0,"col":5,"sizeX":3,"sizeY":3,"color":1,"fontColor":0,"icon":0,"widget":1,"title":"Current Performance Objects","hideTitle":true},"Database Sizes":{"row":0,"col":2,"sizeX":3,"sizeY":3,"color":1,"fontColor":0,"icon":0,"widget":1,"title":"Database Sizes"},"Globals Performance":{"row":4,"col":1,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"Globals Performance"},"Journal size history":{"row":3,"col":1,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"Journal size history"},"License History":{"row":2,"col":1,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"License History"},"Object Performance":{"row":1,"col":1,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"Object Performance"},"Routines Performance History":{"row":0,"col":8,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"Routines Performance History"},"Various System Parameters Performance":{"row":3,"col":4,"sizeX":4,"sizeY":2,"color":1,"fontColor":0,"icon":0,"widget":0,"title":"Various System Parameters Performance","hideTitle":true},"WIJ Performance":{"row":0,"col":9,"sizeX":1,"sizeY":1,"color":1,"fontColor":0,"icon":0,"title":"WIJ Performance"},"Current CPU Parameters":{"row":1,"col":8,"sizeX":2,"sizeY":2,"color":1,"fontColor":0,"icon":0,"hideTitle":true,"title":"Current CPU Parameters","widget":0},"Current License Count":{"row":3,"col":8,"sizeX":2,"sizeY":2,"color":1,"fontColor":0,"icon":1,"title":"Current License Count","hideTitle":true,"widget":0}}}}}}
}

}

